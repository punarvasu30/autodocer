//package com.autodocer;
//
//import com.autodocer.DTO.*;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.fasterxml.jackson.databind.node.ArrayNode;
//import com.fasterxml.jackson.databind.node.ObjectNode;
//
//import java.util.List;
//
///**
// * Responsible for converting the parsed API information into a valid
// * OpenAPI 3.0 JSON specification.
// */
//public class OpenApiGenerator {
//
//    private final ObjectMapper objectMapper;
//
//    public OpenApiGenerator() {
//        this.objectMapper = new ObjectMapper();
//    }
//
//    /**
//     * Generates the OpenAPI JSON string.
//     * @param apiInfo The structured list of controller information from the DocumentationParser.
//     * @return A string containing the OpenAPI 3.0 specification in JSON format.
//     */
//    public String generate(List<ControllerInfo> apiInfo) {
//        ObjectNode root = objectMapper.createObjectNode();
//
//        root.put("openapi", "3.0.0");
//        ObjectNode infoNode = root.putObject("info");
//        infoNode.put("title", "Auto-Generated API Documentation");
//        infoNode.put("version", "1.0.0");
//        infoNode.put("description", "Generated by AutoDocER");
//
//        ObjectNode pathsNode = root.putObject("paths");
//        for (ControllerInfo controller : apiInfo) {
//            for (EndpointInfo endpoint : controller.endpoints()) {
//                // THE FIX: Get or create the path item using the full path as the key
//                ObjectNode pathItemNode;
//                if (pathsNode.has(endpoint.path())) {
//                    pathItemNode = (ObjectNode) pathsNode.get(endpoint.path());
//                } else {
//                    pathItemNode = pathsNode.putObject(endpoint.path());
//                }
//
//                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
//                operationNode.put("summary", endpoint.methodName());
//                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className());
//                operationNode.putArray("tags").add(controller.className());
//
//                ArrayNode parametersNode = operationNode.putArray("parameters");
//                for (ParameterInfo param : endpoint.parameters()) {
//                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
//                        buildParameterNode(parametersNode.addObject(), param);
//                    }
//                }
//
//                endpoint.parameters().stream()
//                        .filter(p -> "RequestBody".equals(p.sourceType()))
//                        .findFirst()
//                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));
//
//                ObjectNode responsesNode = operationNode.putObject("responses");
//                ObjectNode response200 = responsesNode.putObject("200");
//                response200.put("description", "Successful operation");
//                if (!"void".equalsIgnoreCase(String.valueOf(endpoint.responseType()))) {
//                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
//                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
//                }
//            }
//        }
//
//        try {
//            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
//        } catch (Exception e) {
//            e.printStackTrace();
//            return "{\"error\": \"Could not generate OpenAPI spec\"}";
//        }
//    }
//
//    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
//        paramNode.put("name", param.name());
//        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query");
//        paramNode.put("required", param.isRequired());
//        paramNode.set("schema", buildSchemaNode(param.type()));
//    }
//
//    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
//        requestBodyNode.put("description", "Request body for " + param.name());
//        requestBodyNode.put("required", param.isRequired());
//        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
//        contentNode.set("schema", buildSchemaNode(param.type()));
//    }
//
//    private ObjectNode buildSchemaNode(Object type) {
//        ObjectNode schemaNode = objectMapper.createObjectNode();
//        if (type instanceof SchemaInfo schema) {
//            schemaNode.put("type", "object");
//            ObjectNode propertiesNode = schemaNode.putObject("properties");
//            for (FieldInfo field : schema.fields()) {
//                propertiesNode.set(field.name(), buildSchemaNode(field.type()));
//            }
//        } else if (type instanceof ArraySchemaInfo arraySchema) {
//            schemaNode.put("type", "array");
//            schemaNode.set("items", buildSchemaNode(arraySchema.itemType()));
//        } else {
//            String typeName = String.valueOf(type);
//            if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
//                schemaNode.put("type", "integer");
//                schemaNode.put("format", "int32");
//            } else if (typeName.equalsIgnoreCase("Long")) {
//                schemaNode.put("type", "integer");
//                schemaNode.put("format", "int64");
//            } else if (typeName.equalsIgnoreCase("Double")) {
//                schemaNode.put("type", "number");
//                schemaNode.put("format", "double");
//            } else if (typeName.equalsIgnoreCase("Float")) {
//                schemaNode.put("type", "number");
//                schemaNode.put("format", "float");
//            } else if (typeName.equalsIgnoreCase("Boolean")) {
//                schemaNode.put("type", "boolean");
//            } else {
//                schemaNode.put("type", "string");
//            }
//        }
//        return schemaNode;
//    }
//}
//
package com.autodocer;

// Import the new wrapper class from DocumentationParser
import com.autodocer.DocumentationParser.ApiDocumentationResult;
// Ensure correct import for your DTOs/Records
import com.autodocer.DTO.*; // Or com.autodocer.api.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

/**
 * Responsible for converting the parsed API information into a valid
 * OpenAPI 3.0 JSON specification.
 */
public class OpenApiGenerator {

    private final ObjectMapper objectMapper;

    public OpenApiGenerator() {
        this.objectMapper = new ObjectMapper();
    }

    /**
     * UPDATED: Generates the OpenAPI JSON string.
     * @param documentationResult The combined result containing server and controller info.
     * @return A string containing the OpenAPI 3.0 specification in JSON format.
     */
    public String generate(ApiDocumentationResult documentationResult) {
        ObjectNode root = objectMapper.createObjectNode();

        // 1. Add basic OpenAPI info
        root.put("openapi", "3.0.0");
        ObjectNode infoNode = root.putObject("info");
        infoNode.put("title", "Auto-Generated API Documentation");
        infoNode.put("version", "1.0.0"); // Consider making this configurable later
        infoNode.put("description", "Generated by AutoDocER");

        // --- NEW: Add the Servers section ---
        ArrayNode serversNode = root.putArray("servers");
        List<ServerData> servers = documentationResult.servers(); // Get servers from the result
        if (servers == null || servers.isEmpty()) {
            // Add a default server if none were found/provided
            ObjectNode defaultServer = serversNode.addObject();
            defaultServer.put("url", "/");
            defaultServer.put("description", "Default Server (Relative Path)");
        } else {
            for (ServerData server : servers) {
                ObjectNode serverNode = serversNode.addObject();
                serverNode.put("url", server.url());
                if (server.description() != null && !server.description().isEmpty()) {
                    serverNode.put("description", server.description());
                }
            }
        }
        // --- End NEW ---

        // 2. Create the 'paths' object and populate it
        ObjectNode pathsNode = root.putObject("paths");
        List<ControllerInfo> apiInfo = documentationResult.controllers(); // Extract controllers
        for (ControllerInfo controller : apiInfo) {
            for (EndpointInfo endpoint : controller.endpoints()) {
                ObjectNode pathItemNode;
                if (pathsNode.has(endpoint.path())) {
                    pathItemNode = (ObjectNode) pathsNode.get(endpoint.path());
                } else {
                    pathItemNode = pathsNode.putObject(endpoint.path());
                }

                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
                // Use summary/description if available, otherwise fallback to method name
                operationNode.put("summary", endpoint.summary() != null ? endpoint.summary() : endpoint.methodName());
                if (endpoint.description() != null) {
                    operationNode.put("description", endpoint.description());
                }
                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className());
                operationNode.putArray("tags").add(controller.className());

                ArrayNode parametersNode = operationNode.putArray("parameters");
                for (ParameterInfo param : endpoint.parameters()) {
                    // Exclude RequestBody and Unknown parameters from the main parameters list
                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
                        buildParameterNode(parametersNode.addObject(), param);
                    }
                }

                // Handle RequestBody separately
                endpoint.parameters().stream()
                        .filter(p -> "RequestBody".equals(p.sourceType()))
                        .findFirst()
                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));

                ObjectNode responsesNode = operationNode.putObject("responses");
                ObjectNode response200 = responsesNode.putObject("200");
                response200.put("description", "Successful operation");
                // Check if responseType is actually void before adding content
                if (endpoint.responseType() != null
                        && !(endpoint.responseType() instanceof String responseString
                        && (responseString.equalsIgnoreCase("void") || responseString.isEmpty())))
                {
                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
                }
            }
        }

        // 3. Convert the JSON object to a pretty-printed string
        try {
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
        } catch (Exception e) {
            e.printStackTrace();
            // Provide a more informative error message in the JSON
            return "{\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Error\"}, \"paths\": {}, \"error\": \"Could not generate OpenAPI spec: " + e.getMessage().replace("\"", "'") + "\"}";
        }
    }

    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
        paramNode.put("name", param.name());
        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query"); // Assume path or query
        paramNode.put("required", param.isRequired());
        paramNode.set("schema", buildSchemaNode(param.type()));
    }

    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
        requestBodyNode.put("description", "Request body"); // Simple description
        requestBodyNode.put("required", param.isRequired());
        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
        contentNode.set("schema", buildSchemaNode(param.type()));
    }

    private ObjectNode buildSchemaNode(Object type) {
        ObjectNode schemaNode = objectMapper.createObjectNode();
        if (type instanceof SchemaInfo schema) {
            schemaNode.put("type", "object");
            ObjectNode propertiesNode = schemaNode.putObject("properties");
            for (FieldInfo field : schema.fields()) {
                propertiesNode.set(field.name(), buildSchemaNode(field.type()));
            }
        } else if (type instanceof ArraySchemaInfo arraySchema) {
            schemaNode.put("type", "array");
            // Recursively build the schema for the items in the array
            schemaNode.set("items", buildSchemaNode(arraySchema.itemType()));
        } else if (type instanceof String typeName) { // It's a simple type represented by its name
            // Map common Java types to OpenAPI Schema types
            if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
                schemaNode.put("type", "integer");
                schemaNode.put("format", "int32");
            } else if (typeName.equalsIgnoreCase("Long") || typeName.equalsIgnoreCase("long")) {
                schemaNode.put("type", "integer");
                schemaNode.put("format", "int64");
            } else if (typeName.equalsIgnoreCase("Double") || typeName.equalsIgnoreCase("double")) {
                schemaNode.put("type", "number");
                schemaNode.put("format", "double");
            } else if (typeName.equalsIgnoreCase("Float") || typeName.equalsIgnoreCase("float")) {
                schemaNode.put("type", "number");
                schemaNode.put("format", "float");
            } else if (typeName.equalsIgnoreCase("Boolean") || typeName.equalsIgnoreCase("boolean")) {
                schemaNode.put("type", "boolean");
            } else if (typeName.equalsIgnoreCase("byte") || typeName.equalsIgnoreCase("Byte")) {
                schemaNode.put("type", "string");
                schemaNode.put("format", "byte"); // Often represents base64 encoded string
            } else if (typeName.equalsIgnoreCase("LocalDate")) {
                schemaNode.put("type", "string");
                schemaNode.put("format", "date");
            } else if (typeName.equalsIgnoreCase("LocalDateTime") || typeName.equalsIgnoreCase("Date") || typeName.equalsIgnoreCase("Timestamp")) {
                schemaNode.put("type", "string");
                schemaNode.put("format", "date-time");
            } else if (typeName.equalsIgnoreCase("BigDecimal") || typeName.equalsIgnoreCase("BigInteger")) {
                schemaNode.put("type", "number"); // Or string depending on precision needs
            } else if (typeName.equalsIgnoreCase("UUID")) {
                schemaNode.put("type", "string");
                schemaNode.put("format", "uuid");
            } else if (typeName.equalsIgnoreCase("Object")) {
                schemaNode.put("type", "object"); // Generic object
            }
            // Add more mappings as needed (e.g., File, byte[])
            else { // Default to string for unknown simple types
                schemaNode.put("type", "string");
                if (!typeName.equals("String")) { // Add description if it wasn't originally String
                    schemaNode.put("description", "Type: " + typeName);
                }
            }
        } else if (type != null) {
            // Fallback for unexpected type object
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown complex type: " + type.getClass().getName());
        } else {
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown null type");
        }
        return schemaNode;
    }
}