package com.autodocer;

import com.autodocer.DTO.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

/**
 * Responsible for converting the parsed API information into a valid
 * OpenAPI 3.0 JSON specification.
 */
public class OpenApiGenerator {

    private final ObjectMapper objectMapper;

    public OpenApiGenerator() {
        // ObjectMapper is the main class from the Jackson library for working with JSON
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Generates the OpenAPI JSON string.
     * @param apiInfo The structured list of controller information from the DocumentationParser.
     * @return A string containing the OpenAPI 3.0 specification in JSON format.
     */
    public String generate(List<ControllerInfo> apiInfo) {
        // Create the root of the JSON document
        ObjectNode root = objectMapper.createObjectNode();

        // 1. Add basic OpenAPI info
        root.put("openapi", "3.0.0");
        ObjectNode infoNode = root.putObject("info");
        infoNode.put("title", "Auto-Generated API Documentation");
        infoNode.put("version", "1.0.0");
        infoNode.put("description", "Generated by AutoDocER");

        // 2. Create the 'paths' object and populate it
        ObjectNode pathsNode = root.putObject("paths");
        for (ControllerInfo controller : apiInfo) {
            for (EndpointInfo endpoint : controller.endpoints()) {
                // Get or create the JSON object for this specific path (e.g., /api/users/{id})
                ObjectNode pathItemNode = pathsNode.withObject(endpoint.path());

                // Create the JSON object for the HTTP method (e.g., 'get', 'post')
                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
                operationNode.put("summary", endpoint.methodName());
                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className()); // Make it unique
                operationNode.putArray("tags").add(controller.className());

                // Add parameters (PathVariable, RequestParam)
                ArrayNode parametersNode = operationNode.putArray("parameters");
                for (ParameterInfo param : endpoint.parameters()) {
                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
                        buildParameterNode(parametersNode.addObject(), param);
                    }
                }

                // Add request body
                endpoint.parameters().stream()
                        .filter(p -> "RequestBody".equals(p.sourceType()))
                        .findFirst()
                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));


                // Add responses
                ObjectNode responsesNode = operationNode.putObject("responses");
                ObjectNode response200 = responsesNode.putObject("200");
                response200.put("description", "Successful operation");
                if (!"void".equalsIgnoreCase(String.valueOf(endpoint.responseType()))) {
                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
                }
            }
        }


        // 3. Convert the JSON object to a pretty-printed string
        try {
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
        } catch (Exception e) {
            e.printStackTrace();
            return "{\"error\": \"Could not generate OpenAPI spec\"}";
        }
    }

    /**
     * Builds the JSON for a single parameter (PathVariable or RequestParam).
     */
    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
        paramNode.put("name", param.name());
        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query");
        paramNode.put("required", param.isRequired());
        paramNode.set("schema", buildSchemaNode(param.type()));
    }

    /**
     * Builds the JSON for the requestBody.
     */
    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
        requestBodyNode.put("description", "Request body for " + param.name());
        requestBodyNode.put("required", param.isRequired());
        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
        contentNode.set("schema", buildSchemaNode(param.type()));
    }

    /**
     * Recursively builds a JSON Schema node from our internal data models.
     * This is the core of the schema generation.
     */
    private ObjectNode buildSchemaNode(Object type) {
        ObjectNode schemaNode = objectMapper.createObjectNode();
        if (type instanceof SchemaInfo schema) {
            schemaNode.put("type", "object");
            ObjectNode propertiesNode = schemaNode.putObject("properties");
            for (FieldInfo field : schema.fields()) {
                propertiesNode.set(field.name(), buildSchemaNode(field.type()));
            }
        } else if (type instanceof ArraySchemaInfo arraySchema) {
            schemaNode.put("type", "array");
            schemaNode.set("items", buildSchemaNode(arraySchema.itemType()));
        } else { // It's a simple String type
            String typeName = String.valueOf(type);
            if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
                schemaNode.put("type", "integer");
                schemaNode.put("format", "int32");
            } else if (typeName.equalsIgnoreCase("Long")) {
                schemaNode.put("type", "integer");
                schemaNode.put("format", "int64");
            } else if (typeName.equalsIgnoreCase("Double")) {
                schemaNode.put("type", "number");
                schemaNode.put("format", "double");
            } else if (typeName.equalsIgnoreCase("Float")) {
                schemaNode.put("type", "number");
                schemaNode.put("format", "float");
            } else if (typeName.equalsIgnoreCase("Boolean")) {
                schemaNode.put("type", "boolean");
            } else {
                schemaNode.put("type", "string");
            }
        }
        return schemaNode;
    }
}

