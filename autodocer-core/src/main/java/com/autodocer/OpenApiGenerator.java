package com.autodocer;

// Import the new wrapper class from DocumentationParser
import com.autodocer.DocumentationParser.ApiDocumentationResult;
// Ensure correct import for your DTOs/Records
import com.autodocer.DTO.*; // Or com.autodocer.api.*;
import com.autodocer.DTO.ValidationConstraints; // <-- ADDED
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

/**
 * Responsible for converting the parsed API information into a valid
 * OpenAPI 3.0 JSON specification.
 */
public class OpenApiGenerator {

    private final ObjectMapper objectMapper;

    public OpenApiGenerator() {
        this.objectMapper = new ObjectMapper();
    }

    /**
     * UPDATED: Generates the OpenAPI JSON string.
     * @param documentationResult The combined result containing server and controller info.
     * @return A string containing the OpenAPI 3.0 specification in JSON format.
     */
    public String generate(ApiDocumentationResult documentationResult) {
        ObjectNode root = objectMapper.createObjectNode();

        // 1. Add basic OpenAPI info
        root.put("openapi", "3.0.0");
        ObjectNode infoNode = root.putObject("info");
        infoNode.put("title", "Auto-Generated API Documentation");
        infoNode.put("version", "1.0.0"); // Consider making this configurable later
        infoNode.put("description", "Generated by AutoDocER");

        // --- NEW: Add the Servers section ---
        ArrayNode serversNode = root.putArray("servers");
        List<ServerData> servers = documentationResult.servers(); // Get servers from the result
        if (servers == null || servers.isEmpty()) {
            // Add a default server if none were found/provided
            ObjectNode defaultServer = serversNode.addObject();
            defaultServer.put("url", "/");
            defaultServer.put("description", "Default Server (Relative Path)");
        } else {
            for (ServerData server : servers) {
                ObjectNode serverNode = serversNode.addObject();
                serverNode.put("url", server.url());
                if (server.description() != null && !server.description().isEmpty()) {
                    serverNode.put("description", server.description());
                }
            }
        }
        // --- End NEW ---

        // 2. Create the 'paths' object and populate it
        ObjectNode pathsNode = root.putObject("paths");
        List<ControllerInfo> apiInfo = documentationResult.controllers(); // Extract controllers
        for (ControllerInfo controller : apiInfo) {
            for (EndpointInfo endpoint : controller.endpoints()) {
                ObjectNode pathItemNode;
                if (pathsNode.has(endpoint.path())) {
                    pathItemNode = (ObjectNode) pathsNode.get(endpoint.path());
                } else {
                    pathItemNode = pathsNode.putObject(endpoint.path());
                }

                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
                // Use summary/description if available, otherwise fallback to method name
                operationNode.put("summary", endpoint.summary() != null ? endpoint.summary() : endpoint.methodName());
                if (endpoint.description() != null) {
                    operationNode.put("description", endpoint.description());
                }
                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className());
                operationNode.putArray("tags").add(controller.className());

                ArrayNode parametersNode = operationNode.putArray("parameters");
                for (ParameterInfo param : endpoint.parameters()) {
                    // Exclude RequestBody and Unknown parameters from the main parameters list
                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
                        buildParameterNode(parametersNode.addObject(), param);
                    }
                }

                // Handle RequestBody separately
                endpoint.parameters().stream()
                        .filter(p -> "RequestBody".equals(p.sourceType()))
                        .findFirst()
                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));

                ObjectNode responsesNode = operationNode.putObject("responses");
                ObjectNode response200 = responsesNode.putObject("200");
                response200.put("description", "Successful operation");

                // UPDATED: Check if responseType is actually void before adding content
                if (endpoint.responseType() != null
                        && !(endpoint.responseType() instanceof String responseString
                        && (responseString.equalsIgnoreCase("void") || responseString.isEmpty())))
                {
                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
                }
            }
        }

        // 3. Convert the JSON object to a pretty-printed string
        try {
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
        } catch (Exception e) {
            e.printStackTrace();
            // Provide a more informative error message in the JSON
            return "{\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Error\"}, \"paths\": {}, \"error\": \"Could not generate OpenAPI spec: " + e.getMessage().replace("\"", "'") + "\"}";
        }
    }

    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
        paramNode.put("name", param.name());
        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query"); // Assume path or query
        paramNode.put("required", param.isRequired());
        paramNode.set("schema", buildSchemaNode(param.type()));

        // NOTE: We could extend this later to read validation annotations
        // from parameters (e.g., @RequestParam @Size) not just schema fields.
        // For now, this is outside the scope of the SchemaParser change.
    }

    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
        requestBodyNode.put("description", "Request body"); // Simple description
        requestBodyNode.put("required", param.isRequired());
        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
        contentNode.set("schema", buildSchemaNode(param.type()));
    }

    /**
     * UPDATED: Builds OpenAPI schema nodes with better handling for arrays/collections
     * AND includes validation constraints.
     */
    private ObjectNode buildSchemaNode(Object type) {
        ObjectNode schemaNode = objectMapper.createObjectNode();

        // Handle complex object schemas
        if (type instanceof SchemaInfo schema) {
            schemaNode.put("type", "object");

            // --- NEW: Add 'required' fields list ---
            if (schema.requiredFields() != null && !schema.requiredFields().isEmpty()) {
                ArrayNode requiredNode = schemaNode.putArray("required");
                for (String reqField : schema.requiredFields()) {
                    requiredNode.add(reqField);
                }
            }
            // --- END NEW ---

            ObjectNode propertiesNode = schemaNode.putObject("properties");
            for (FieldInfo field : schema.fields()) {

                // --- NEW: Apply validation constraints ---
                // 1. Recursively build the base schema for the field's type
                ObjectNode fieldSchemaNode = buildSchemaNode(field.type());

                // 2. Apply validation constraints if they exist
                if (field.constraints() != null) {
                    ValidationConstraints constraints = field.constraints();

                    // Note: OpenAPI uses "minimum" and "maximum"
                    if (constraints.min() != null) fieldSchemaNode.put("minimum", constraints.min());
                    if (constraints.max() != null) fieldSchemaNode.put("maximum", constraints.max());

                    if (constraints.minLength() != null) fieldSchemaNode.put("minLength", constraints.minLength());
                    if (constraints.maxLength() != null) fieldSchemaNode.put("maxLength", constraints.maxLength());

                    if (constraints.pattern() != null) fieldSchemaNode.put("pattern", constraints.pattern());

                    // This will correctly add/overwrite format (e.g., "email", "date")
                    if (constraints.format() != null) fieldSchemaNode.put("format", constraints.format());
                }

                // 3. Add the enhanced node to the properties list
                propertiesNode.set(field.name(), fieldSchemaNode);
                // --- END NEW ---
            }
        }
        // UPDATED: Handle array/collection schemas properly
        else if (type instanceof ArraySchemaInfo arraySchema) {
            schemaNode.put("type", "array");
            // Recursively build the schema for the items in the array
            ObjectNode itemsSchema = buildSchemaNode(arraySchema.itemType());
            schemaNode.set("items", itemsSchema);

            // Debug logging to verify proper array handling
            System.out.println("     -> Building array schema with item type: " + arraySchema.itemType());
        }
        // Handle simple type names (String representation)
        else if (type instanceof String typeName) {
            mapSimpleTypeToSchema(schemaNode, typeName);
        }
        // Fallback for unexpected types
        else if (type != null) {
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown complex type: " + type.getClass().getName());
        } else {
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown null type");
        }

        return schemaNode;
    }

    /**
     * Helper method to map Java simple types to OpenAPI schema types
     */
    private void mapSimpleTypeToSchema(ObjectNode schemaNode, String typeName) {
        // Map common Java types to OpenAPI Schema types
        if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
            schemaNode.put("type", "integer");
            schemaNode.put("format", "int32");
        } else if (typeName.equalsIgnoreCase("Long") || typeName.equalsIgnoreCase("long")) {
            schemaNode.put("type", "integer");
            schemaNode.put("format", "int64");
        } else if (typeName.equalsIgnoreCase("Double") || typeName.equalsIgnoreCase("double")) {
            schemaNode.put("type", "number");
            schemaNode.put("format", "double");
        } else if (typeName.equalsIgnoreCase("Float") || typeName.equalsIgnoreCase("float")) {
            schemaNode.put("type", "number");
            schemaNode.put("format", "float");
        } else if (typeName.equalsIgnoreCase("Boolean") || typeName.equalsIgnoreCase("boolean")) {
            schemaNode.put("type", "boolean");
        } else if (typeName.equalsIgnoreCase("byte") || typeName.equalsIgnoreCase("Byte")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "byte"); // Often represents base64 encoded string
        } else if (typeName.equalsIgnoreCase("LocalDate")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "date");
        } else if (typeName.equalsIgnoreCase("LocalDateTime") || typeName.equalsIgnoreCase("Date") ||
                typeName.equalsIgnoreCase("Timestamp") || typeName.equalsIgnoreCase("Instant") ||
                typeName.equalsIgnoreCase("OffsetDateTime") || typeName.equalsIgnoreCase("ZonedDateTime")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "date-time");
        } else if (typeName.equalsIgnoreCase("BigDecimal") || typeName.equalsIgnoreCase("BigInteger")) {
            schemaNode.put("type", "number"); // Or string depending on precision needs
        } else if (typeName.equalsIgnoreCase("UUID")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "uuid");
        } else if (typeName.equalsIgnoreCase("Object")) {
            schemaNode.put("type", "object"); // Generic object
        }
        // Handle collection type names that might slip through
        else if (typeName.equalsIgnoreCase("List") || typeName.equalsIgnoreCase("Set") ||
                typeName.equalsIgnoreCase("Collection") || typeName.equalsIgnoreCase("ArrayList") ||
                typeName.equalsIgnoreCase("HashSet")) {
            schemaNode.put("type", "array");
            schemaNode.putObject("items").put("type", "object"); // Generic array of objects
        }
        // Default to string for unknown simple types
        else {
            schemaNode.put("type", "string");
            if (!typeName.equals("String")) { // Add description if it wasn't originally String
                schemaNode.put("description", "Type: " + typeName);
            }
        }
    }
}