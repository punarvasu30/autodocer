//
//package com.autodocer;
//
//// Import the new wrapper class from DocumentationParser
//import com.autodocer.DocumentationParser.ApiDocumentationResult;
//// Ensure correct import for your DTOs/Records
//import com.autodocer.DTO.*; // Or com.autodocer.api.*;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.fasterxml.jackson.databind.node.ArrayNode;
//import com.fasterxml.jackson.databind.node.ObjectNode;
//
//import java.util.List;
//
///**
// * Responsible for converting the parsed API information into a valid
// * OpenAPI 3.0 JSON specification.
// */
//public class OpenApiGenerator {
//
//    private final ObjectMapper objectMapper;
//
//    public OpenApiGenerator() {
//        this.objectMapper = new ObjectMapper();
//    }
//
//    /**
//     * UPDATED: Generates the OpenAPI JSON string.
//     * @param documentationResult The combined result containing server and controller info.
//     * @return A string containing the OpenAPI 3.0 specification in JSON format.
//     */
//    public String generate(ApiDocumentationResult documentationResult) {
//        ObjectNode root = objectMapper.createObjectNode();
//
//        // 1. Add basic OpenAPI info
//        root.put("openapi", "3.0.0");
//        ObjectNode infoNode = root.putObject("info");
//        infoNode.put("title", "Auto-Generated API Documentation");
//        infoNode.put("version", "1.0.0"); // Consider making this configurable later
//        infoNode.put("description", "Generated by AutoDocER");
//
//        // --- NEW: Add the Servers section ---
//        ArrayNode serversNode = root.putArray("servers");
//        List<ServerData> servers = documentationResult.servers(); // Get servers from the result
//        if (servers == null || servers.isEmpty()) {
//            // Add a default server if none were found/provided
//            ObjectNode defaultServer = serversNode.addObject();
//            defaultServer.put("url", "/");
//            defaultServer.put("description", "Default Server (Relative Path)");
//        } else {
//            for (ServerData server : servers) {
//                ObjectNode serverNode = serversNode.addObject();
//                serverNode.put("url", server.url());
//                if (server.description() != null && !server.description().isEmpty()) {
//                    serverNode.put("description", server.description());
//                }
//            }
//        }
//        // --- End NEW ---
//
//        // 2. Create the 'paths' object and populate it
//        ObjectNode pathsNode = root.putObject("paths");
//        List<ControllerInfo> apiInfo = documentationResult.controllers(); // Extract controllers
//        for (ControllerInfo controller : apiInfo) {
//            for (EndpointInfo endpoint : controller.endpoints()) {
//                ObjectNode pathItemNode;
//                if (pathsNode.has(endpoint.path())) {
//                    pathItemNode = (ObjectNode) pathsNode.get(endpoint.path());
//                } else {
//                    pathItemNode = pathsNode.putObject(endpoint.path());
//                }
//
//                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
//                // Use summary/description if available, otherwise fallback to method name
//                operationNode.put("summary", endpoint.summary() != null ? endpoint.summary() : endpoint.methodName());
//                if (endpoint.description() != null) {
//                    operationNode.put("description", endpoint.description());
//                }
//                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className());
//                operationNode.putArray("tags").add(controller.className());
//
//                ArrayNode parametersNode = operationNode.putArray("parameters");
//                for (ParameterInfo param : endpoint.parameters()) {
//                    // Exclude RequestBody and Unknown parameters from the main parameters list
//                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
//                        buildParameterNode(parametersNode.addObject(), param);
//                    }
//                }
//
//                // Handle RequestBody separately
//                endpoint.parameters().stream()
//                        .filter(p -> "RequestBody".equals(p.sourceType()))
//                        .findFirst()
//                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));
//
//                ObjectNode responsesNode = operationNode.putObject("responses");
//                ObjectNode response200 = responsesNode.putObject("200");
//                response200.put("description", "Successful operation");
//                // Check if responseType is actually void before adding content
//                if (endpoint.responseType() != null
//                        && !(endpoint.responseType() instanceof String responseString
//                        && (responseString.equalsIgnoreCase("void") || responseString.isEmpty())))
//                {
//                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
//                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
//                }
//            }
//        }
//
//        // 3. Convert the JSON object to a pretty-printed string
//        try {
//            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
//        } catch (Exception e) {
//            e.printStackTrace();
//            // Provide a more informative error message in the JSON
//            return "{\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Error\"}, \"paths\": {}, \"error\": \"Could not generate OpenAPI spec: " + e.getMessage().replace("\"", "'") + "\"}";
//        }
//    }
//
//    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
//        paramNode.put("name", param.name());
//        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query"); // Assume path or query
//        paramNode.put("required", param.isRequired());
//        paramNode.set("schema", buildSchemaNode(param.type()));
//    }
//
//    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
//        requestBodyNode.put("description", "Request body"); // Simple description
//        requestBodyNode.put("required", param.isRequired());
//        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
//        contentNode.set("schema", buildSchemaNode(param.type()));
//    }
//
//    private ObjectNode buildSchemaNode(Object type) {
//        ObjectNode schemaNode = objectMapper.createObjectNode();
//        if (type instanceof SchemaInfo schema) {
//            schemaNode.put("type", "object");
//            ObjectNode propertiesNode = schemaNode.putObject("properties");
//            for (FieldInfo field : schema.fields()) {
//                propertiesNode.set(field.name(), buildSchemaNode(field.type()));
//            }
//        } else if (type instanceof ArraySchemaInfo arraySchema) {
//            schemaNode.put("type", "array");
//            // Recursively build the schema for the items in the array
//            schemaNode.set("items", buildSchemaNode(arraySchema.itemType()));
//        } else if (type instanceof String typeName) { // It's a simple type represented by its name
//            // Map common Java types to OpenAPI Schema types
//            if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
//                schemaNode.put("type", "integer");
//                schemaNode.put("format", "int32");
//            } else if (typeName.equalsIgnoreCase("Long") || typeName.equalsIgnoreCase("long")) {
//                schemaNode.put("type", "integer");
//                schemaNode.put("format", "int64");
//            } else if (typeName.equalsIgnoreCase("Double") || typeName.equalsIgnoreCase("double")) {
//                schemaNode.put("type", "number");
//                schemaNode.put("format", "double");
//            } else if (typeName.equalsIgnoreCase("Float") || typeName.equalsIgnoreCase("float")) {
//                schemaNode.put("type", "number");
//                schemaNode.put("format", "float");
//            } else if (typeName.equalsIgnoreCase("Boolean") || typeName.equalsIgnoreCase("boolean")) {
//                schemaNode.put("type", "boolean");
//            } else if (typeName.equalsIgnoreCase("byte") || typeName.equalsIgnoreCase("Byte")) {
//                schemaNode.put("type", "string");
//                schemaNode.put("format", "byte"); // Often represents base64 encoded string
//            } else if (typeName.equalsIgnoreCase("LocalDate")) {
//                schemaNode.put("type", "string");
//                schemaNode.put("format", "date");
//            } else if (typeName.equalsIgnoreCase("LocalDateTime") || typeName.equalsIgnoreCase("Date") || typeName.equalsIgnoreCase("Timestamp")) {
//                schemaNode.put("type", "string");
//                schemaNode.put("format", "date-time");
//            } else if (typeName.equalsIgnoreCase("BigDecimal") || typeName.equalsIgnoreCase("BigInteger")) {
//                schemaNode.put("type", "number"); // Or string depending on precision needs
//            } else if (typeName.equalsIgnoreCase("UUID")) {
//                schemaNode.put("type", "string");
//                schemaNode.put("format", "uuid");
//            } else if (typeName.equalsIgnoreCase("Object")) {
//                schemaNode.put("type", "object"); // Generic object
//            }
//            // Add more mappings as needed (e.g., File, byte[])
//            else { // Default to string for unknown simple types
//                schemaNode.put("type", "string");
//                if (!typeName.equals("String")) { // Add description if it wasn't originally String
//                    schemaNode.put("description", "Type: " + typeName);
//                }
//            }
//        } else if (type != null) {
//            // Fallback for unexpected type object
//            schemaNode.put("type", "string");
//            schemaNode.put("description", "Unknown complex type: " + type.getClass().getName());
//        } else {
//            schemaNode.put("type", "string");
//            schemaNode.put("description", "Unknown null type");
//        }
//        return schemaNode;
//    }
//}


package com.autodocer;

// Import the new wrapper class from DocumentationParser
import com.autodocer.DocumentationParser.ApiDocumentationResult;
// Ensure correct import for your DTOs/Records
import com.autodocer.DTO.*; // Or com.autodocer.api.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.util.List;

/**
 * Responsible for converting the parsed API information into a valid
 * OpenAPI 3.0 JSON specification.
 */
public class OpenApiGenerator {

    private final ObjectMapper objectMapper;

    public OpenApiGenerator() {
        this.objectMapper = new ObjectMapper();
    }

    /**
     * UPDATED: Generates the OpenAPI JSON string.
     * @param documentationResult The combined result containing server and controller info.
     * @return A string containing the OpenAPI 3.0 specification in JSON format.
     */
    public String generate(ApiDocumentationResult documentationResult) {
        ObjectNode root = objectMapper.createObjectNode();

        // 1. Add basic OpenAPI info
        root.put("openapi", "3.0.0");
        ObjectNode infoNode = root.putObject("info");
        infoNode.put("title", "Auto-Generated API Documentation");
        infoNode.put("version", "1.0.0"); // Consider making this configurable later
        infoNode.put("description", "Generated by AutoDocER");

        // --- NEW: Add the Servers section ---
        ArrayNode serversNode = root.putArray("servers");
        List<ServerData> servers = documentationResult.servers(); // Get servers from the result
        if (servers == null || servers.isEmpty()) {
            // Add a default server if none were found/provided
            ObjectNode defaultServer = serversNode.addObject();
            defaultServer.put("url", "/");
            defaultServer.put("description", "Default Server (Relative Path)");
        } else {
            for (ServerData server : servers) {
                ObjectNode serverNode = serversNode.addObject();
                serverNode.put("url", server.url());
                if (server.description() != null && !server.description().isEmpty()) {
                    serverNode.put("description", server.description());
                }
            }
        }
        // --- End NEW ---

        // 2. Create the 'paths' object and populate it
        ObjectNode pathsNode = root.putObject("paths");
        List<ControllerInfo> apiInfo = documentationResult.controllers(); // Extract controllers
        for (ControllerInfo controller : apiInfo) {
            for (EndpointInfo endpoint : controller.endpoints()) {
                ObjectNode pathItemNode;
                if (pathsNode.has(endpoint.path())) {
                    pathItemNode = (ObjectNode) pathsNode.get(endpoint.path());
                } else {
                    pathItemNode = pathsNode.putObject(endpoint.path());
                }

                ObjectNode operationNode = pathItemNode.putObject(endpoint.httpMethod().toLowerCase());
                // Use summary/description if available, otherwise fallback to method name
                operationNode.put("summary", endpoint.summary() != null ? endpoint.summary() : endpoint.methodName());
                if (endpoint.description() != null) {
                    operationNode.put("description", endpoint.description());
                }
                operationNode.put("operationId", endpoint.methodName() + "_" + controller.className());
                operationNode.putArray("tags").add(controller.className());

                ArrayNode parametersNode = operationNode.putArray("parameters");
                for (ParameterInfo param : endpoint.parameters()) {
                    // Exclude RequestBody and Unknown parameters from the main parameters list
                    if (!"RequestBody".equals(param.sourceType()) && !"Unknown".equals(param.sourceType())) {
                        buildParameterNode(parametersNode.addObject(), param);
                    }
                }

                // Handle RequestBody separately
                endpoint.parameters().stream()
                        .filter(p -> "RequestBody".equals(p.sourceType()))
                        .findFirst()
                        .ifPresent(p -> buildRequestBodyNode(operationNode.putObject("requestBody"), p));

                ObjectNode responsesNode = operationNode.putObject("responses");
                ObjectNode response200 = responsesNode.putObject("200");
                response200.put("description", "Successful operation");

                // UPDATED: Check if responseType is actually void before adding content
                if (endpoint.responseType() != null
                        && !(endpoint.responseType() instanceof String responseString
                        && (responseString.equalsIgnoreCase("void") || responseString.isEmpty())))
                {
                    ObjectNode contentNode = response200.putObject("content").putObject("application/json");
                    contentNode.set("schema", buildSchemaNode(endpoint.responseType()));
                }
            }
        }

        // 3. Convert the JSON object to a pretty-printed string
        try {
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(root);
        } catch (Exception e) {
            e.printStackTrace();
            // Provide a more informative error message in the JSON
            return "{\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Error\"}, \"paths\": {}, \"error\": \"Could not generate OpenAPI spec: " + e.getMessage().replace("\"", "'") + "\"}";
        }
    }

    private void buildParameterNode(ObjectNode paramNode, ParameterInfo param) {
        paramNode.put("name", param.name());
        paramNode.put("in", param.sourceType().equalsIgnoreCase("PathVariable") ? "path" : "query"); // Assume path or query
        paramNode.put("required", param.isRequired());
        paramNode.set("schema", buildSchemaNode(param.type()));
    }

    private void buildRequestBodyNode(ObjectNode requestBodyNode, ParameterInfo param) {
        requestBodyNode.put("description", "Request body"); // Simple description
        requestBodyNode.put("required", param.isRequired());
        ObjectNode contentNode = requestBodyNode.putObject("content").putObject("application/json");
        contentNode.set("schema", buildSchemaNode(param.type()));
    }

    /**
     * UPDATED: Builds OpenAPI schema nodes with better handling for arrays/collections
     */
    private ObjectNode buildSchemaNode(Object type) {
        ObjectNode schemaNode = objectMapper.createObjectNode();

        // Handle complex object schemas
        if (type instanceof SchemaInfo schema) {
            schemaNode.put("type", "object");
            ObjectNode propertiesNode = schemaNode.putObject("properties");
            for (FieldInfo field : schema.fields()) {
                propertiesNode.set(field.name(), buildSchemaNode(field.type()));
            }
        }
        // UPDATED: Handle array/collection schemas properly
        else if (type instanceof ArraySchemaInfo arraySchema) {
            schemaNode.put("type", "array");
            // Recursively build the schema for the items in the array
            ObjectNode itemsSchema = buildSchemaNode(arraySchema.itemType());
            schemaNode.set("items", itemsSchema);

            // Debug logging to verify proper array handling
            System.out.println("    -> Building array schema with item type: " + arraySchema.itemType());
        }
        // Handle simple type names (String representation)
        else if (type instanceof String typeName) {
            mapSimpleTypeToSchema(schemaNode, typeName);
        }
        // Fallback for unexpected types
        else if (type != null) {
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown complex type: " + type.getClass().getName());
        } else {
            schemaNode.put("type", "string");
            schemaNode.put("description", "Unknown null type");
        }

        return schemaNode;
    }

    /**
     * NEW: Helper method to map Java simple types to OpenAPI schema types
     */
    private void mapSimpleTypeToSchema(ObjectNode schemaNode, String typeName) {
        // Map common Java types to OpenAPI Schema types
        if (typeName.equalsIgnoreCase("Integer") || typeName.equalsIgnoreCase("int")) {
            schemaNode.put("type", "integer");
            schemaNode.put("format", "int32");
        } else if (typeName.equalsIgnoreCase("Long") || typeName.equalsIgnoreCase("long")) {
            schemaNode.put("type", "integer");
            schemaNode.put("format", "int64");
        } else if (typeName.equalsIgnoreCase("Double") || typeName.equalsIgnoreCase("double")) {
            schemaNode.put("type", "number");
            schemaNode.put("format", "double");
        } else if (typeName.equalsIgnoreCase("Float") || typeName.equalsIgnoreCase("float")) {
            schemaNode.put("type", "number");
            schemaNode.put("format", "float");
        } else if (typeName.equalsIgnoreCase("Boolean") || typeName.equalsIgnoreCase("boolean")) {
            schemaNode.put("type", "boolean");
        } else if (typeName.equalsIgnoreCase("byte") || typeName.equalsIgnoreCase("Byte")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "byte"); // Often represents base64 encoded string
        } else if (typeName.equalsIgnoreCase("LocalDate")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "date");
        } else if (typeName.equalsIgnoreCase("LocalDateTime") || typeName.equalsIgnoreCase("Date") || typeName.equalsIgnoreCase("Timestamp")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "date-time");
        } else if (typeName.equalsIgnoreCase("BigDecimal") || typeName.equalsIgnoreCase("BigInteger")) {
            schemaNode.put("type", "number"); // Or string depending on precision needs
        } else if (typeName.equalsIgnoreCase("UUID")) {
            schemaNode.put("type", "string");
            schemaNode.put("format", "uuid");
        } else if (typeName.equalsIgnoreCase("Object")) {
            schemaNode.put("type", "object"); // Generic object
        }
        // Handle collection type names that might slip through
        else if (typeName.equalsIgnoreCase("List") || typeName.equalsIgnoreCase("Set") ||
                typeName.equalsIgnoreCase("Collection") || typeName.equalsIgnoreCase("ArrayList") ||
                typeName.equalsIgnoreCase("HashSet")) {
            schemaNode.put("type", "array");
            schemaNode.putObject("items").put("type", "object"); // Generic array of objects
        }
        // Default to string for unknown simple types
        else {
            schemaNode.put("type", "string");
            if (!typeName.equals("String")) { // Add description if it wasn't originally String
                schemaNode.put("description", "Type: " + typeName);
            }
        }
    }
}